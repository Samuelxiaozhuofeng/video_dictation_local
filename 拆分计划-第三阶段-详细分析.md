# App.tsx 拆分计划 · 第三阶段（UI 组件化重构）

> **当前状态**: App.tsx 有 758 行，已完成第一、第二阶段的 Hook 拆分
>
> **第三阶段目标**: 将 App.tsx 从 758 行减少到 **400-500 行**
>
> **核心策略**: 将 PRACTICE 模式的 UI（288 行）拆分为独立组件

---

## 📊 当前代码分析

### App.tsx 结构（758 行）

| 部分 | 行数范围 | 行数 | 说明 |
|------|---------|------|------|
| Imports & Setup | 1-33 | 33 | 导入和类型定义 |
| Hook 调用 | 34-160 | 127 | 5个自定义 Hook 的调用 |
| Handlers | 161-381 | 221 | 事件处理函数 |
| - handleStartPractice | 171-216 | 46 | 开始练习 |
| - handleContinueFromLibrary | 223-276 | 54 | 从历史继续 |
| - 其他小函数 | - | ~120 | 各种辅助函数 |
| SETTINGS 渲染 | 385-387 | 3 | 设置页面 |
| LIBRARY 渲染 | 389-391 | 3 | 收藏库页面 |
| UPLOAD 渲染 | 393-469 | 77 | 上传页面 |
| **PRACTICE 渲染** | **471-758** | **288** | **⚠️ 练习模式 UI（最大问题）** |

### PRACTICE 模式 UI 详细结构（288 行）

| 组件部分 | 行数范围 | 行数 | 说明 |
|---------|---------|------|------|
| 容器 div | 476 | 1 | 全屏容器 |
| **顶部浮动头** | 479-521 | 43 | Logo、Section 选择器、Saved 按钮、Exit 按钮 |
| **视频层** | 524-577 | 54 | video 元素、录音覆盖层、完成对话框、播放按钮 |
| **底部交互层** | 580-693 | 114 | 输入区、进度条、控制按钮 |
| - 输入/反馈区 | 584-602 | 19 | InputFeedback 组件调用 |
| - 进度条 | 607-624 | 18 | 时间轴和拖动条 |
| - 控制按钮 | 627-690 | 64 | 播放、跳过、保存、Anki 等按钮 |
| **Saved 抽屉** | 696-754 | 59 | 右侧收藏列表抽屉 |

### 问题点优先级

1. 🔴 **高优先级**: PRACTICE UI（288 行）- 需要拆分为组件
2. 🟡 **中优先级**: handleStartPractice（46 行）- 可以简化
3. 🟢 **低优先级**: SRT 解析逻辑 - 已在 Hook 中，无需改动

---

## 步骤一：创建 PracticeLayout 组件（拆分 PRACTICE UI）

**目标**: 将 PRACTICE 模式的 288 行 JSX 拆分为独立组件，减少 App.tsx 约 250 行

### 1.1 创建主容器组件

**文件**: `components/PracticeLayout.tsx`

**职责**:
- 作为 PRACTICE 模式的主容器
- 组合所有子组件（Header、Video、Controls、Drawer）
- 接收 props 并传递给子组件

**Props 设计**:
```typescript
interface PracticeLayoutProps {
  // 字幕和分段
  subtitles: Subtitle[];
  fullSubtitles: Subtitle[];
  sections: VideoSection[];
  currentSectionIndex: number;
  currentSubtitleIndex: number;

  // 练习状态
  mode: PracticeMode;
  showSectionComplete: boolean;

  // 视频控制
  videoRef: React.RefObject<HTMLVideoElement>;
  videoSrc: string | null;
  isPlaying: boolean;
  volume: number;
  playbackSpeed: number;
  progress: number;

  // Saved Lines
  savedIds: Set<number>;
  showSavedList: boolean;
  savedItems: Subtitle[];
  isCurrentSaved: boolean;

  // Anki
  ankiConfig: AnkiConfig | null;
  ankiStatus: 'idle' | 'recording' | 'adding' | 'success' | 'error';

  // 事件处理
  onExit: () => void;
  onSwitchSection: (index: number) => void;
  onToggleSavedList: (show: boolean) => void;
  onTogglePlay: () => void;
  onReplayCurrent: (autoAdvanceAfter?: boolean) => void;
  onSkip: (direction: 'prev' | 'next') => void;
  onProgressSeek: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onToggleSaveCurrent: () => void;
  onAddToAnki: () => void;
  onWordToAnki: (word: string, definition: string) => void;
  onNextSection: () => void;
  onSetShowSectionComplete: (show: boolean) => void;
  onSetVolume: (volume: number) => void;
  onSetPlaybackSpeed: (speed: number) => void;
  onInputComplete: (wasCorrect: boolean) => void;
  onContinue: () => void;
  onDeleteSavedItem: (id: number, e: React.MouseEvent) => void;
  onJumpToSaved: (id: number) => void;
}
```

### 1.2 创建子组件（可选，逐步拆分）

可以进一步拆分为更小的组件：

1. **PracticeHeader.tsx** (43 行)
   - Logo、Section 选择器、Saved 按钮、Exit 按钮

2. **PracticeVideoLayer.tsx** (54 行)
   - video 元素、录音覆盖层、完成对话框、播放按钮

3. **PracticeControls.tsx** (114 行)
   - 输入区、进度条、控制按钮

4. **SavedDrawer.tsx** (59 行)
   - 右侧收藏列表抽屉

**建议**: 先创建 `PracticeLayout.tsx` 包含所有 JSX，验证通过后再考虑进一步拆分

### 1.3 在 App.tsx 中使用 PracticeLayout

替换 PRACTICE 分支（471-758 行）为简洁的组件调用（约 30 行）

### 1.4 验收点

- ✅ TypeScript 编译通过
- ✅ PRACTICE 模式所有功能正常（播放、输入、保存、Anki）
- ✅ App.tsx 减少约 250 行（从 758 行到 ~500 行）
- ✅ 代码结构更清晰，职责分离

---

## 步骤二：简化 handleStartPractice（可选优化）

**目标**: 将 handleStartPractice 从 46 行简化到 20-30 行

**当前问题**:
- 文件读取、SRT 解析、视频记录创建、状态设置都混在一起
- 错误处理分散

**优化方案**:

### 2.1 在 usePracticeSession 中添加 prepareSession 方法

```typescript
// hooks/usePracticeSession.ts
export interface UsePracticeSessionReturn {
  // ... 现有返回值 ...

  // 新增：准备会话（整合初始化逻辑）
  prepareSession: (params: {
    subtitleText: string;
    startIndex?: number;
    startSectionIndex?: number;
  }) => {
    parsed: Subtitle[];
    sections: VideoSection[];
  } | null;
}
```

### 2.2 简化 App.tsx 中的 handleStartPractice

```typescript
const handleStartPractice = async (
  vFile?: File,
  sFile?: File,
  startIndex?: number,
  startSectionIndex?: number,
  videoId?: string
) => {
  const vf = vFile || videoFile;
  const sf = sFile || subtitleFile;
  if (!vf || !sf) return;

  try {
    const subText = await sf.text();
    const result = prepareSession({ subtitleText: subText, startIndex, startSectionIndex });

    if (!result) {
      alert("No subtitles found in file. Please check the format.");
      return;
    }

    // 保存视频记录
    let recordId = videoId;
    if (!videoId) {
      const record = await createVideoRecord(vf, sf, subText, result.parsed.length);
      recordId = record.id;
    }

    // 加载保存的字幕
    const previouslySavedIds = loadSavedIds(result.parsed);

    // 设置状态并切换到练习模式
    setCurrentVideoId(recordId || null);
    setSavedIds(previouslySavedIds);
    setVideoSrc(URL.createObjectURL(vf));
    setAppState(AppState.PRACTICE);
  } catch (e) {
    alert("Error parsing subtitle file.");
    console.error(e);
  }
};
```

**预期效果**: 从 46 行减少到 ~30 行

---

## 步骤三：优化 handleContinueFromLibrary（可选）

**目标**: 将文件选择逻辑封装到 useVideoHistory Hook 中

**当前问题**:
- 54 行代码，包含复杂的文件选择逻辑
- File System Access API 调用分散

**优化方案**:

### 3.1 在 useVideoHistory 中添加 getOrSelectVideoFile 方法

```typescript
// hooks/useVideoHistory.ts
export interface UseVideoHistoryReturn {
  // ... 现有返回值 ...

  // 新增：获取或选择视频文件
  getOrSelectVideoFile: (record: VideoRecord) => Promise<File | null>;
}
```

### 3.2 简化 App.tsx 中的 handleContinueFromLibrary

```typescript
const handleContinueFromLibrary = async (record: VideoRecord) => {
  try {
    const videoFileFromHandle = await getOrSelectVideoFile(record);
    if (!videoFileFromHandle) return;

    const subtitleFileFromRecord = getSubtitleFileFromRecord(record);

    setVideoFile(videoFileFromHandle);
    setSubtitleFile(subtitleFileFromRecord);

    await handleStartPractice(
      videoFileFromHandle,
      subtitleFileFromRecord,
      record.currentSubtitleIndex,
      record.currentSectionIndex,
      record.id
    );
  } catch (error) {
    console.error('Failed to continue from library:', error);
    alert('Failed to load video. Please try again.');
  }
};
```

**预期效果**: 从 54 行减少到 ~20 行

---

## 步骤四：进一步拆分 PracticeLayout 子组件（可选）

**目标**: 如果 PracticeLayout.tsx 仍然过大（>200 行），可以进一步拆分

### 4.1 创建 PracticeHeader.tsx

**文件**: `components/PracticeHeader.tsx`

**内容**: App.tsx 的 479-521 行（43 行）

**Props**:
```typescript
interface PracticeHeaderProps {
  sections: VideoSection[];
  currentSectionIndex: number;
  savedIds: Set<number>;
  onSwitchSection: (index: number) => void;
  onToggleSavedList: () => void;
  onExit: () => void;
}
```

### 4.2 创建 SavedDrawer.tsx

**文件**: `components/SavedDrawer.tsx`

**内容**: App.tsx 的 696-754 行（59 行）

**Props**:
```typescript
interface SavedDrawerProps {
  show: boolean;
  savedItems: Subtitle[];
  onClose: () => void;
  onDeleteItem: (id: number, e: React.MouseEvent) => void;
  onJumpTo: (id: number) => void;
}
```

### 4.3 创建 PracticeControls.tsx

**文件**: `components/PracticeControls.tsx`

**内容**: App.tsx 的 605-691 行（87 行）

**Props**:
```typescript
interface PracticeControlsProps {
  videoRef: React.RefObject<HTMLVideoElement>;
  progress: number;
  volume: number;
  playbackSpeed: number;
  isPlaying: boolean;
  isCurrentSaved: boolean;
  ankiConfig: AnkiConfig | null;
  ankiStatus: 'idle' | 'recording' | 'adding' | 'success' | 'error';
  onProgressSeek: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onSetVolume: (volume: number) => void;
  onTogglePlay: () => void;
  onReplayCurrent: () => void;
  onSkip: (direction: 'prev' | 'next') => void;
  onToggleSaveCurrent: () => void;
  onAddToAnki: () => void;
  onSetPlaybackSpeed: (speed: number) => void;
}
```

---

## 预期最终效果

### 代码行数对比

| 文件 | 重构前 | 重构后 | 变化 |
|------|--------|--------|------|
| **App.tsx** | **758** | **~450** | **-308 (-40.6%)** |
| PracticeLayout.tsx | 0 | ~300 | +300 |
| PracticeHeader.tsx (可选) | 0 | ~50 | +50 |
| SavedDrawer.tsx (可选) | 0 | ~70 | +70 |
| PracticeControls.tsx (可选) | 0 | ~100 | +100 |

### App.tsx 最终职责

重构后的 App.tsx (~450 行) 将只负责：

1. ✅ **Hook 组合** - 整合 5 个自定义 Hook
2. ✅ **状态协调** - 管理应用级状态
3. ✅ **路由管理** - UPLOAD / PRACTICE / SETTINGS / LIBRARY 切换
4. ✅ **简单事件处理** - 薄封装的事件转发

### 优势

1. **可维护性** ✅ - 每个组件职责单一，易于定位问题
2. **可测试性** ✅ - UI 组件可以独立测试
3. **可复用性** ✅ - 组件可以在其他地方复用
4. **可读性** ✅ - App.tsx 结构清晰，一目了然

---

## 实施顺序建议

### 必做步骤（高优先级）

1. ✅ **步骤一（跳过）**: SRT 解析逻辑已在 Hook 中，无需改动
2. 🔴 **步骤一（实际）**: 创建 PracticeLayout.tsx - **最重要，减少 250+ 行**

### 可选步骤（中低优先级）

3. 🟡 **步骤二**: 简化 handleStartPractice - 减少 ~15 行
4. 🟡 **步骤三**: 优化 handleContinueFromLibrary - 减少 ~30 行
5. 🟢 **步骤四**: 进一步拆分 PracticeLayout 子组件 - 提高可维护性

### 验证清单

每个步骤完成后：
- [ ] TypeScript 编译无错误
- [ ] 运行 `npm run dev` 测试应用
- [ ] 测试 PRACTICE 模式所有功能
- [ ] 测试上传、历史记录、设置等功能
- [ ] 检查控制台无错误

---

## 总结

第三阶段的核心是 **UI 组件化**，通过将 PRACTICE 模式的 288 行 JSX 拆分为独立组件，可以：

- 将 App.tsx 从 758 行减少到 ~450 行（减少 40%）
- 提高代码可维护性和可读性
- 为后续功能扩展打下良好基础

**建议**: 先完成步骤一（创建 PracticeLayout.tsx），这是最重要的改进，可以立即带来显著效果。其他步骤可以根据时间和需求逐步完成。
